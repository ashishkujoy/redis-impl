package ds

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

type MockedClock struct {
	time int
}

func (m *MockedClock) CurrentMillis() int {
	return m.time
}

func NewMockedClock(time int) *MockedClock {
	return &MockedClock{time: time}
}

func TestAddInANewStream(t *testing.T) {
	streams := NewStreams()
	_, err := streams.Add("Key1", "1526919030473-0", nil)

	assert.NoError(t, err)
}

func TestAddInAExistingStream(t *testing.T) {
	streams := NewStreams()
	_, _ = streams.Add("Key1", "1526919030473-0", nil)
	_, err := streams.Add("Key1", "1526919030473-1", nil)

	assert.NoError(t, err)
}

func TestAddWithSameSequenceAsHeadOfStream(t *testing.T) {
	streams := NewStreams()
	_, _ = streams.Add("Key1", "1526919030473-0", nil)
	_, err := streams.Add("Key1", "1526919030473-0", nil)

	assert.Error(t, err)
}

func TestAddWithHigherTimestampThanHeadOfStream(t *testing.T) {
	streams := NewStreams()
	_, _ = streams.Add("Key1", "1526919030473-10", nil)
	_, err := streams.Add("Key1", "1526919030500-9", nil)

	assert.NoError(t, err)
}

func TestAddWithLowerTimestampThanHeadOfStream(t *testing.T) {
	streams := NewStreams()
	_, _ = streams.Add("Key1", "1526919030473-10", nil)
	_, err := streams.Add("Key1", "1526919030400-9", nil)

	assert.Error(t, err)
}

func TestAddWithZeroZeroKey(t *testing.T) {
	streams := NewStreams()
	_, err := streams.Add("Key1", "0-0", nil)

	assert.Error(t, err)
}

func TestIncludes(t *testing.T) {
	streams := NewStreams()
	contains := streams.Contains("Key1")
	assert.False(t, contains)

	_, _ = streams.Add("Key2", "1526919030400-10", nil)
	contains = streams.Contains("Key1")
	assert.False(t, contains)

	_, _ = streams.Add("Key1", "1526919030400-10", nil)
	contains = streams.Contains("Key1")
	assert.True(t, contains)
}

func TestAddWithAutogenerateSequenceInNonExistingStream(t *testing.T) {
	streams := NewStreams()
	id, err := streams.Add("Key1", "1526919030473-*", nil)

	assert.NoError(t, err)
	assert.Equal(t, "1526919030473-0", id)
}

func TestAddWithAutogenerateSequenceInExistingStream(t *testing.T) {
	streams := NewStreams()
	id, err := streams.Add("Key1", "1526919030473-10", nil)

	assert.NoError(t, err)
	assert.Equal(t, "1526919030473-10", id)

	id, err = streams.Add("Key1", "1526919030473-*", nil)

	assert.NoError(t, err)
	assert.Equal(t, "1526919030473-11", id)
}

func TestAddWithAutogenerateSequenceInExistingStreamWithMultipleTimestampEnteries(t *testing.T) {
	streams := NewStreams()
	id, err := streams.Add("Key1", "1526919030473-10", nil)
	assert.NoError(t, err)
	assert.Equal(t, "1526919030473-10", id)

	id, err = streams.Add("Key1", "1526919030474-10", nil)
	assert.NoError(t, err)
	assert.Equal(t, "1526919030474-10", id)

	id, err = streams.Add("Key1", "1526919030474-*", nil)
	assert.NoError(t, err)
	assert.Equal(t, "1526919030474-11", id)
}

func TestAddWithAutogenerateSequenceWithTimestampZero(t *testing.T) {
	streams := NewStreams()
	id, err := streams.Add("Key1", "0-*", nil)

	assert.NoError(t, err)
	assert.Equal(t, "0-1", id)
}

func TestAddWithFullyAutogeneratedId(t *testing.T) {
	streams := NewStreamsWithClock(NewMockedClock(1526919030474))
	id, err := streams.Add("Key1", "*", nil)

	assert.NoError(t, err)
	assert.Equal(t, "1526919030474-0", id)
}

func TestListNonExistingStream(t *testing.T) {
	streams := NewStreams()
	list := streams.List(
		"Key1",
		"1526919030474-0",
		"1526919030474-10",
	)

	assert.Equal(t, 0, len(list))
}

func TestListWithNoMatchingEntry(t *testing.T) {
	streams := NewStreams()
	_, _ = streams.Add("Key1", "1526919030473-0", [][]byte{[]byte("foo")})
	_, _ = streams.Add("Key1", "1526919030473-1", [][]byte{[]byte("bar")})
	_, _ = streams.Add("Key1", "1526919030474-0", [][]byte{[]byte("bazz")})

	entries := streams.List(
		"Key1",
		"1526919030471-0",
		"1526919030472-10",
	)
	assert.Equal(t, 0, len(entries))

	entries = streams.List(
		"Key1",
		"1526919030474-11",
		"1526919030475-10",
	)
	assert.Equal(t, 0, len(entries))

	entries = streams.List(
		"Key1",
		"1526919030480-11",
		"1526919030470-10",
	)
	assert.Equal(t, 0, len(entries))
}

func TestStreamIdInRange(t *testing.T) {
	tests := []struct {
		name           string
		id             *StreamID
		start, end     *StreamID
		inRange        bool
		startInclusive bool
	}{
		{
			name:           "id is in range",
			start:          NewStreamID(4, 4),
			id:             NewStreamID(5, 5),
			end:            NewStreamID(6, 6),
			inRange:        true,
			startInclusive: true,
		},
		{
			name:           "timestamp equals to start and sequence greater than start sequence",
			start:          NewStreamID(4, 4),
			id:             NewStreamID(4, 5),
			end:            NewStreamID(6, 6),
			inRange:        true,
			startInclusive: true,
		},
		{
			name:           "timestamp equals to start and sequence equal to the start sequence",
			start:          NewStreamID(4, 5),
			id:             NewStreamID(4, 5),
			end:            NewStreamID(6, 6),
			inRange:        true,
			startInclusive: true,
		},
		{
			name:           "timestamp equals to start and sequence equal to the start sequence with start exclusive",
			start:          NewStreamID(4, 5),
			id:             NewStreamID(4, 5),
			end:            NewStreamID(6, 6),
			inRange:        false,
			startInclusive: false,
		},
		{
			name:           "timestamp equals to start and sequence lesser than the start sequence",
			start:          NewStreamID(4, 3),
			id:             NewStreamID(4, 2),
			end:            NewStreamID(6, 6),
			inRange:        false,
			startInclusive: true,
		},
		{
			name:           "timestamp equals to end and sequence lesser than the end sequence",
			start:          NewStreamID(2, 3),
			id:             NewStreamID(4, 2),
			end:            NewStreamID(4, 3),
			inRange:        true,
			startInclusive: true,
		},
		{
			name:           "timestamp equals to end and sequence equal to the end sequence",
			start:          NewStreamID(2, 3),
			id:             NewStreamID(4, 5),
			end:            NewStreamID(4, 5),
			inRange:        true,
			startInclusive: true,
		},
		{
			name:           "timestamp equals to end and sequence greater than the end sequence",
			start:          NewStreamID(2, 3),
			id:             NewStreamID(4, 6),
			end:            NewStreamID(4, 5),
			inRange:        false,
			startInclusive: true,
		},
	}
	for _, test := range tests {
		t.Run(test.name, func(t *testing.T) {
			inRange := test.id.isInRange(test.start, test.end, test.startInclusive)
			assert.Equal(t, test.inRange, inRange)
		})
	}
}

func TestListWithMatchingEntry(t *testing.T) {
	streams := NewStreams()
	_, _ = streams.Add("Key1", "1526919030473-0", [][]byte{[]byte("V1")})
	_, _ = streams.Add("Key1", "1526919030473-2", [][]byte{[]byte("V2")})
	_, _ = streams.Add("Key1", "1526919030473-5", [][]byte{[]byte("V3")})
	_, _ = streams.Add("Key1", "1526919030474-0", [][]byte{[]byte("V4")})
	_, _ = streams.Add("Key1", "1526919030474-1", [][]byte{[]byte("V5")})

	entries := streams.List(
		"Key1",
		"1526919030420-0",
		"1526919030473-0",
	)
	assert.Equal(t, 1, len(entries))

	entries = streams.List(
		"Key1",
		"1526919030473-1",
		"1526919030473-10",
	)
	assert.Equal(t, 2, len(entries))

	entries = streams.List(
		"Key1",
		"1526919030473-1",
		"1526919030475-10",
	)
	assert.Equal(t, 4, len(entries))

	entries = streams.List(
		"Key1",
		"1526919030474-2",
		"1526919030475-10",
	)
	assert.Equal(t, 0, len(entries))
}

func TestListWithStartSymbol(t *testing.T) {
	streams := NewStreams()
	_, _ = streams.Add("Key1", "1526919030473-0", [][]byte{[]byte("V1")})
	_, _ = streams.Add("Key1", "1526919030473-2", [][]byte{[]byte("V2")})

	entries := streams.List("Key1", "-", "1526919030473-2")
	assert.Equal(t, 2, len(entries))

	entries = streams.List("Key1", "-", "1526919030473-1")
	assert.Equal(t, 1, len(entries))
}

func TestListWithEndSymbol(t *testing.T) {
	streams := NewStreams()
	_, _ = streams.Add("Key1", "1526919030473-0", [][]byte{[]byte("V1")})
	_, _ = streams.Add("Key1", "1526919030473-5", [][]byte{[]byte("V2")})
	_, _ = streams.Add("Key1", "1526919030474-5", [][]byte{[]byte("V2")})

	entries := streams.List("Key1", "1526919030473-5", "+")
	assert.Equal(t, 2, len(entries))
}

func TestListGreaterThan(t *testing.T) {
	streams := NewStreams()
	_, _ = streams.Add("Key1", "1526919030473-0", [][]byte{[]byte("V1")})
	_, _ = streams.Add("Key1", "1526919030473-5", [][]byte{[]byte("V2")})
	_, _ = streams.Add("Key1", "1526919030474-5", [][]byte{[]byte("V2")})

	entries := streams.ListGreaterThan("Key1", "1526919030473-0")
	assert.Equal(t, 2, len(entries))
}
